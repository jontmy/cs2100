\section{Control}
\textbf{Control signals} are generated by a \textbf{control unit} based on the type of instruction.

The control unit is a \textbf{combinational circuit} which takes in the 6-bit opcode
and the 5-bit function code, and outputs the 8 control signals.

\code{funct} is only needed to determine \code{ALUSrc}; every other control signal can be
derived from \code{opcode} alone.

\subsection{\code{ALUControl}}
We start with a simplified 1-bit ALU.

\begin{defn}{1-bit MIPS ALU}
    4 control signals are needed:
    \begin{enumerate}
        \keyitem*{\code{Ainvert}}{\code{1} to invert \code{A}, \code{0} otherwise}
        \keyitem*{\code{Binvert}}{\code{1} to invert \code{B}, \code{0} otherwise}
        \keyitem*{\code{operation} (2 bits)}{select one of the 3 results}
    \end{enumerate}

    5 I/O signals:
    \begin{enumerate}
        \keyitem*{\code{A}}{input}
        \keyitem*{\code{B}}{input}
        \keyitem*{\code{Cin}}{carry in}
        \keyitem*{\code{Cout}}{carry out}
        \keyitem*{\code{result}}{output}
    \end{enumerate}
\end{defn}

These 1-bit ALUs are daisy-chained to form a 32-bit ALU.

The carries from one of the 1-bit ALUs is fed out via \code{Cout} and into the next one via \code{Cin}.

\code{Ainvert} and \code{Binvert} control the multiplexers which select between their inputs and their negated values:

\begin{tblr}{|c|c|} \hline
    \textbf{\code{Xinvert}} & \textbf{output} \\ \hline
    \code{0} & \code{X} \\ \hline[dashed]
    \code{1} & \code{NOT(X)} \\ \hline
\end{tblr}

The \code{operation} control signal selects one of the 3 results from the \code{AND} gate, \code{OR} gate, and the adder \code{ADD}:

\begin{tblr}{|c|c|} \hline
    \textbf{\code{operation}} & \textbf{output} \\ \hline
    \code{00} & \code{AND} \\
    \code{01} & \code{OR} \\ \hline[dashed]
    \code{10} & \code{ADD} \\
    \code{11} & \code{SLT} \\ \hline
\end{tblr}

\begin{defn}{1-bit subtraction}
    \code{Cin} is set to \code{1} due to 2s complement:

    \code{A $-$ B $\equiv$ A $+$ (-B) $\equiv$ A $+$ B' $+$ 1}
\end{defn}

\begin{defn}{\code{ALUControl}}
    In MSB to LSB order, \code{ALUControl} comprises of:
    \begin{enumerate}
        \item \code{Ainvert}
        \item \code{Binvert}
        \item \code{operation}
    \end{enumerate}
\end{defn}

\subsubsection{\code{ALUOp}}
It is necessary to use the \textbf{multi-level decoding approach} to simplify the design process and size of
the main controller.

\textbf{\code{ALUOp}} is an intermediate 2-bit control signal which is generated from \code{opcode}
and used with \code{funct} to determine \code{ALUControl}.

\begin{tblr}{|l|l|X|l|} \hline
    \textbf{instruction} & \textbf{\code{ALUOp}} & \textbf{\code{funct}} & \textbf{\code{ALUControl}} \\ \hline
    \code{lw, sw} & \code{00} & \code{XXXXXX} & \code{0010} \\ \hline[dashed]
    \code{beq} & \code{01} & \code{XXXXXX} & \code{0110} \\ \hline[dashed]
    \code{add} & \code{10} & \code{100000} & \code{0010} \\ \hline[dashed]
    \code{sub} & \code{10} & \code{100010} & \code{0110} \\ \hline[dashed]
    \code{and} & \code{10} & \code{100100} & \code{0000} \\ \hline[dashed]
    \code{or} & \code{10} & \code{100101} & \code{0001} \\ \hline[dashed]
    \code{slt} & \code{10} & \code{101010} & \code{0111} \\ \hline
\end{tblr}

In general, \code{ALUOp} is \code{10} for \code{R}-format instructions.
